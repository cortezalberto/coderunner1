# Runner Image

This is a minimal Docker image used for sandboxed execution of student code. It provides an isolated, secure environment for running Python code with pytest.

## Overview

The runner image is the **innermost security layer** of the Python Playground. Student code is executed inside this container with strict resource limits and isolation to prevent malicious code from affecting the host system.

## Features

- **Minimal Base**: Python 3.11-slim with only pytest installed (~150MB total)
- **Non-root User**: Runs as user `sandbox` (uid 1000) to prevent privilege escalation
- **No Network**: Container runs with `--network none` by default
- **Read-only Filesystem**: All system files are immutable during execution
- **Resource Limits**: CPU and memory are strictly constrained
- **Timeout Enforcement**: Maximum execution time is enforced at container level
- **Clean Execution**: Each submission gets a fresh container instance

## Architecture

```
Worker Service
    ↓
Creates Workspace (/workspaces/sandbox-<uuid>/)
    ↓
Spawns Docker Container (py-playground-runner)
    ↓
Executes pytest inside container
    ↓
Collects results (report.json)
    ↓
Destroys Container
```

## Building

```bash
# From project root
docker build -t py-playground-runner:latest ./runner

# Or rebuild with docker compose
docker compose build runner
```

## Image Contents

- **Base**: `python:3.11-slim`
- **Installed Packages**: `pytest` only
- **User**: `sandbox` (uid=1000, gid=1000)
- **Working Directory**: `/workspace`
- **Entrypoint**: None (set by worker at runtime)

## Security Measures

The worker applies multiple security layers when running this image:

### 1. Network Isolation
```bash
--network none
```
Container has no network access (no internet, no host network, no other containers).

### 2. Read-only Filesystem
```bash
--read-only
```
All files except explicitly mounted tmpfs are immutable.

### 3. Temporary Writable Spaces
```bash
--tmpfs /tmp:rw,noexec,nosuid,size=64m
--tmpfs /workspace:rw,noexec,nosuid,size=128m
```
Small tmpfs mounts for:
- `/tmp`: pytest cache and temporary files (64MB max)
- `/workspace`: test execution and output (128MB max)
- `noexec`: Cannot execute binaries from these locations
- `nosuid`: Cannot escalate privileges via setuid

### 4. Resource Limits
```bash
--cpus=1.0                # Maximum 1 CPU core
--memory=256m             # Maximum 256MB RAM
--memory-swap=256m        # No swap allowed
```

### 5. Timeout Enforcement
```python
# In worker/services/docker_runner.py
timeout_seconds = metadata.get('timeout_sec', 5)
container.wait(timeout=timeout_seconds)
```
Default: 5 seconds per submission (configurable per problem).

### 6. Automatic Cleanup
```bash
--rm  # Container auto-removes after execution
```
Plus periodic workspace cleanup (files >1 hour old deleted every 30 minutes).

## Execution Flow

1. **Worker prepares workspace**:
   ```
   /workspaces/sandbox-<uuid>/
   ├── student_code.py       # Student's submitted code
   ├── tests_public.py       # Visible tests
   ├── tests_hidden.py       # Hidden tests
   ├── conftest.py           # Pytest configuration
   └── report.json           # Generated by pytest
   ```

2. **Worker spawns container**:
   ```bash
   docker run --rm \
     --network none \
     --read-only \
     --tmpfs /tmp:rw,noexec,nosuid,size=64m \
     --tmpfs /workspace:rw,noexec,nosuid,size=128m \
     --cpus=1.0 \
     --memory=256m \
     --memory-swap=256m \
     -v /host/workspaces/sandbox-<uuid>:/workspace:rw \
     -w /workspace \
     -u sandbox \
     py-playground-runner:latest \
     pytest -v --tb=short --json-report --json-report-file=report.json .
   ```

3. **Container executes**:
   - Pytest imports `student_code.py`
   - Runs all test functions from `tests_public.py` and `tests_hidden.py`
   - Generates `report.json` with results
   - Exits with code 0 (tests passed) or 1 (tests failed)

4. **Worker collects results**:
   - Reads `report.json` from workspace
   - Applies rubric scoring
   - Saves to database
   - Deletes workspace (or marks for cleanup)

## Threat Model

**What this protects against**:
- ✅ Network attacks (container has no network)
- ✅ Filesystem tampering (read-only except tmpfs)
- ✅ Resource exhaustion (CPU/memory/disk limits)
- ✅ Privilege escalation (non-root user, nosuid)
- ✅ Fork bombs (container-level limits)
- ✅ Infinite loops (timeout enforcement)
- ✅ Cross-submission contamination (fresh container per run)

**What this does NOT protect against**:
- ❌ Container escape via kernel exploits (use gVisor for this)
- ❌ Side-channel attacks (timing, spectre, etc.)
- ❌ Resource exhaustion at host level if many containers spawn simultaneously
- ❌ Advanced obfuscation techniques (requires static analysis)

**For high-stakes production environments**, consider:
1. Using **gVisor runtime** (`--runtime=runsc`) for kernel-level isolation
2. Running worker on **separate VM/host** from backend/database
3. Adding **static code analysis** before execution
4. Implementing **rate limiting** at submission level (already done: 5 req/min)

## Customization

### Adding Python Packages

If problems require additional packages (e.g., `numpy`, `pandas`):

1. Edit `runner/Dockerfile`:
   ```dockerfile
   RUN pip install --no-cache-dir pytest numpy pandas
   ```

2. Rebuild image:
   ```bash
   docker build -t py-playground-runner:latest ./runner
   ```

3. Restart worker:
   ```bash
   docker compose restart worker
   ```

**Note**: Keep the image minimal for security. Only add packages that are truly necessary.

### Changing Python Version

Edit `runner/Dockerfile`:
```dockerfile
FROM python:3.12-slim  # Change version here
```

### Adjusting Resource Limits

Edit `worker/tasks.py`:
```python
DEFAULT_TIMEOUT = 5      # seconds
DEFAULT_MEMORY_MB = 256  # MB
DEFAULT_CPUS = 1.0       # CPU cores
```

Or set per-problem in `metadata.json`:
```json
{
  "timeout_sec": 10,
  "memory_mb": 512
}
```

## Testing the Runner

### Manual Test

```bash
# Create test workspace
mkdir -p /tmp/test-workspace
cd /tmp/test-workspace

# Create student code
cat > student_code.py <<EOF
def suma(a, b):
    return a + b
EOF

# Create test file
cat > test_suma.py <<EOF
import importlib.util
import os

spec = importlib.util.spec_from_file_location(
    "student_code",
    os.path.join(os.getcwd(), "student_code.py")
)
student = importlib.util.module_from_spec(spec)
spec.loader.exec_module(student)

def test_suma():
    assert student.suma(2, 3) == 5
EOF

# Run in container
docker run --rm \
  -v $(pwd):/workspace:rw \
  -w /workspace \
  py-playground-runner:latest \
  pytest -v test_suma.py
```

Expected output:
```
============================= test session starts ==============================
collected 1 item

test_suma.py::test_suma PASSED                                          [100%]

============================== 1 passed in 0.01s ===============================
```

### Automated Testing

The worker includes integration tests that use this runner image:

```bash
docker compose exec worker pytest worker/tests/test_docker_runner.py -v
```

## Troubleshooting

**"Image not found"**:
```bash
docker build -t py-playground-runner:latest ./runner
```

**"Permission denied" when accessing workspace**:
- Check that workspace files have correct permissions (chmod 666 for files, 777 for dirs)
- Worker creates files as root, runner uses uid=1000

**"Container killed" or timeout errors**:
- Increase timeout in `metadata.json` for that problem
- Or increase `DEFAULT_TIMEOUT` in `worker/tasks.py`

**"Import errors" in student code**:
- Check if required package is installed in runner image
- Add package to `runner/Dockerfile` and rebuild

## Related Documentation

- **Worker Service**: `worker/services/docker_runner.py` - Spawns and manages containers
- **Security**: `backend/validators.py` - Input validation before execution
- **Problem Structure**: `CLAUDE.md` → "Problem Structure" section
- **Architecture**: `CLAUDE.md` → "Critical Architecture Decisions"
